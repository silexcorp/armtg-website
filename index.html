<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR &dash; ThreeJS</title>
    <link rel="stylesheet" href="css/style.css">
    <script src='js/three.min.js'></script>
    <script src="js/ar.js"></script>
    <script>
        THREEx.ArToolkitContext.baseURL = ''
    </script>
</head>

<body>
    <script>
         //////////////////////////////////////////////////////////////////////////////////
         //		Init
         //////////////////////////////////////////////////////////////////////////////////

         // init renderer
        var renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0)
        renderer.setSize(1920, 1080);
        renderer.domElement.style.position = 'absolute'
        renderer.domElement.style.top = '0px'
        renderer.domElement.style.left = '0px'
        document.body.appendChild(renderer.domElement);

         // array of functions for the rendering loop
        var onRenderFcts = [];

         // init scene and camera
        var scene = new THREE.Scene();

         //////////////////////////////////////////////////////////////////////////////////
         //		Initialize a basic camera
         //////////////////////////////////////////////////////////////////////////////////

         // Create a camera
        var camera = new THREE.Camera();
        scene.add(camera);

         ////////////////////////////////////////////////////////////////////////////////
         //          handle arToolkitSource
         ////////////////////////////////////////////////////////////////////////////////

        var arToolkitSource = new THREEx.ArToolkitSource({
            // to read from the webcam
            sourceType: 'webcam',

            // // to read from an image
            // sourceType : 'image',
            // sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/images/img.jpg',

            // to read from a video
            // sourceType : 'video',
            // sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/videos/headtracking.mp4',
        })

         arToolkitSource.init(function onReady() {
            onResize()
        })

         // handle resize
         window.addEventListener('resize', function() {
            onResize()
        })

            function onResize() {
                arToolkitSource.onResize()
                arToolkitSource.copySizeTo(renderer.domElement)
                if (arToolkitContext.arController !== null) {
                    arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                }
            }
            ////////////////////////////////////////////////////////////////////////////////
            //          initialize arToolkitContext
            ////////////////////////////////////////////////////////////////////////////////


            // create atToolkitContext
        var arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/data/camera_para.dat',
            detectionMode: 'mono',
        })
         // initialize it
         arToolkitContext.init(function onCompleted() {
            // copy projection matrix to camera
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        })

         // update artoolkit on every frame
         onRenderFcts.push(function() {
            if (arToolkitSource.ready === false) return

            arToolkitContext.update(arToolkitSource.domElement)

            // update scene.visible if the marker is seen
            scene.visible = camera.visible
        })

         ////////////////////////////////////////////////////////////////////////////////
         //          Create a ArMarkerControls
         ////////////////////////////////////////////////////////////////////////////////

         // init controls for camera
         var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
            type: 'pattern',
            patternUrl: THREEx.ArToolkitContext.baseURL + 'data/data/marker16.pat',
            changeMatrixMode: 'cameraTransformMatrix'
        })
         // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
         scene.visible = false

         //////////////////////////////////////////////////////////////////////////////////
         //		add an object in the scene
         //////////////////////////////////////////////////////////////////////////////////

         // add a torus knot
        var geometry = new THREE.CubeGeometry(0.9, 0.01, 1.2);
        /*var material = new THREE.MeshNormalMaterial({
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });*/
		var material = new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("card.jpg")
		});
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = geometry.parameters.height / 2
		scene.add(mesh);
		var geometry = new THREE.TorusKnotGeometry(0.3, 0.1, 64, 16);
		var material = new THREE.MeshNormalMaterial();
		var mesh = new THREE.Mesh(geometry, material);
		mesh.position.y = 0.5
		//scene.add(mesh);
		 
		function renderCard(card) {
			var texture, material, url;

			texture = THREE.ImageUtils.loadTexture( url );

			texture.wrapS = THREE.RepeatWrapping; 
			texture.wrapT = THREE.RepeatWrapping;

			texture.repeat.set( 4, 4 ); 

			material = new THREE.MeshLambertMaterial({ map : texture });
			card = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
			card.material.side = THREE.DoubleSide;
			card.rotation.z = Math.PI / 2;

			scene.add(card);
		}
		

        onRenderFcts.push(function(delta) {
            //mesh.rotation.x += Math.PI * delta
        })

         //////////////////////////////////////////////////////////////////////////////////
         //		render the whole thing on the page
         //////////////////////////////////////////////////////////////////////////////////

         // render the scene
         onRenderFcts.push(function() {
            renderer.render(scene, camera);
        })

         // run the rendering loop
         var lastTimeMsec = null
         requestAnimationFrame(function animate(nowMsec) {
            // keep looping
            requestAnimationFrame(animate);
            // measure time
            lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
            var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
            lastTimeMsec = nowMsec
            // call each update function
            onRenderFcts.forEach(function(onRenderFct) {
                onRenderFct(deltaMsec / 1000, nowMsec / 1000)
            })
        })
    </script>
</body>

</html>
