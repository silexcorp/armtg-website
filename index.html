<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR &dash; ThreeJS</title>
    <link rel="stylesheet" href="css/style.css">
    <script src='js/three.min.js'></script>
    <script src="js/ar.js"></script>
    <script>
        THREEx.ArToolkitContext.baseURL = ''
    </script>
</head>

<body>
    <script>
        var renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0)
        renderer.setSize(1920, 1080);
        renderer.domElement.style.position = 'absolute'
        renderer.domElement.style.top = '0px'
        renderer.domElement.style.left = '0px'
        document.body.appendChild(renderer.domElement);
		
        var onRenderFcts = [];

        var scene = new THREE.Scene();

        var camera = new THREE.Camera();
        scene.add(camera);

        var arToolkitSource = new THREEx.ArToolkitSource({
            // to read from the webcam
            sourceType: 'webcam',

            // // to read from an image
            // sourceType : 'image',
            // sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/images/img.jpg',

            // to read from a video
            // sourceType : 'video',
            // sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/videos/headtracking.mp4',
        })

         arToolkitSource.init(function onReady() {
            onResize()
        })

         window.addEventListener('resize', function() {
            onResize()
        })

            function onResize() {
                arToolkitSource.onResize()
                arToolkitSource.copySizeTo(renderer.domElement)
                if (arToolkitContext.arController !== null) {
                    arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                }
            }

        var arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/data/camera_para.dat',
            detectionMode: 'mono',
        })
         arToolkitContext.init(function onCompleted() {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        })

         onRenderFcts.push(function() {
            if (arToolkitSource.ready === false) return

            arToolkitContext.update(arToolkitSource.domElement)

            scene.visible = camera.visible
        })

         var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
            type: 'pattern',
            patternUrl: THREEx.ArToolkitContext.baseURL + '1.patt',//data/data/marker16.pat
            changeMatrixMode: 'cameraTransformMatrix'
        })
         // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
         scene.visible = false

        var geometry = new THREE.CubeGeometry(0.9, 0.01, 1.2);
		var material = new THREE.MeshBasicMaterial({
			map: THREE.ImageUtils.loadTexture("card.jpg")
		});
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = geometry.parameters.height / 2;
		mesh.scale.x = mesh.scale.y = mesh.scale.z = 2.3;
		scene.add(mesh);
		 
		function renderCard(card) {
			var texture, material, url;

			texture = THREE.ImageUtils.loadTexture( url );

			texture.wrapS = THREE.RepeatWrapping; 
			texture.wrapT = THREE.RepeatWrapping;

			texture.repeat.set( 4, 4 ); 

			material = new THREE.MeshLambertMaterial({ map : texture });
			card = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
			card.material.side = THREE.DoubleSide;
			card.rotation.z = Math.PI / 2;

			scene.add(card);
		}
		

        onRenderFcts.push(function(delta) {
            //mesh.rotation.z += Math.PI * delta
        })

         onRenderFcts.push(function() {
            renderer.render(scene, camera);
        })

         var lastTimeMsec = null
         requestAnimationFrame(function animate(nowMsec) {
            requestAnimationFrame(animate);
            lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
            var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
            lastTimeMsec = nowMsec
            onRenderFcts.forEach(function(onRenderFct) {
                onRenderFct(deltaMsec / 1000, nowMsec / 1000)
            })
        })
    </script>
</body>

</html>
